---

## `package.json`
```json
{
  "name": "anjun-gestao-backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "bcrypt": "^5.1.0",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "socket.io": "^4.7.2",
    "sqlite3": "^5.1.6",
    "csv-stringify": "^6.2.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
```

---

## `init-db.sql`
```sql
PRAGMA foreign_keys = ON;

CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  is_admin INTEGER NOT NULL DEFAULT 0
);

CREATE TABLE IF NOT EXISTS employees (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  photo TEXT DEFAULT '',
  est_minutes INTEGER DEFAULT 0
);

CREATE TABLE IF NOT EXISTS tasks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  employee_id INTEGER NOT NULL REFERENCES employees(id),
  task_text TEXT,
  start_ts INTEGER,
  pause_ts INTEGER,
  elapsed_seconds INTEGER DEFAULT 0,
  status TEXT DEFAULT 'idle',
  created_by INTEGER REFERENCES users(id)
);

CREATE TABLE IF NOT EXISTS history (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  employee_id INTEGER,
  task_text TEXT,
  start_ts INTEGER,
  end_ts INTEGER,
  created_at INTEGER DEFAULT (strftime('%s','now')*1000)
);
```

---

## `server.js`
```js
// server.js
const fs = require('fs');
const path = require('path');
const express = require('express');
const bcrypt = require('bcrypt');
const sqlite3 = require('sqlite3').verbose();
const { open } = require('sqlite');
const http = require('http');
const cors = require('cors');
const { Server } = require('socket.io');
const stringify = require('csv-stringify/lib/sync');
const jwt = require('jsonwebtoken');

const PORT = process.env.PORT || 3000;
const DB_FILE = path.resolve(__dirname, 'anjun.db');
const JWT_SECRET = process.env.JWT_SECRET || 'troque-isto-por-uma-chave-secreta';

async function initDb() {
  const db = await open({ filename: DB_FILE, driver: sqlite3.Database });
  const initSQL = fs.readFileSync(path.join(__dirname, 'init-db.sql'), 'utf8');
  await db.exec(initSQL);
  // ensure admin user exists
  const admin = await db.get('SELECT id FROM users WHERE username = ?', 'rodrigoadm');
  if(!admin) {
    const hash = await bcrypt.hash('R16021988&', 10);
    await db.run('INSERT INTO users (username, password_hash, is_admin) VALUES (?, ?, ?)', 'rodrigoadm', hash, 1);
    console.log('Admin criado: rodrigoadm');
  }
  // ensure default employees
  const cur = await db.all('SELECT * FROM employees');
  if(cur.length === 0) {
    const names = ['Isaque','Kelly','Kleber','Vinicius','Washington','(vago)'];
    for(const n of names) {
      await db.run('INSERT INTO employees (name) VALUES (?)', n);
    }
  }
  return db;
}

(async () => {
  const db = await initDb();

  const app = express();
  app.use(express.json({ limit: '10mb' }));
  app.use(cors());

  const server = http.createServer(app);
  const io = new Server(server, { cors: { origin: '*' } });

  // helper auth
  function generateToken(user) {
    return jwt.sign({ id: user.id, username: user.username, is_admin: user.is_admin }, JWT_SECRET, { expiresIn: '12h' });
  }
  function verifyToken(req, res, next) {
    const auth = req.headers.authorization;
    if(!auth) return res.status(401).json({ error: 'no token' });
    const token = auth.replace('Bearer ', '');
    try {
      req.user = jwt.verify(token, JWT_SECRET);
      next();
    } catch(e) {
      return res.status(401).json({ error: 'invalid token' });
    }
  }

  // auth
  app.post('/api/login', async (req, res) => {
    const { username, password } = req.body || {};
    if(!username || !password) return res.status(400).json({ error: 'missing' });
    const user = await db.get('SELECT id, username, password_hash, is_admin FROM users WHERE username = ?', username);
    if(!user) return res.status(404).json({ error: 'user-not-found' });
    const ok = await bcrypt.compare(password, user.password_hash);
    if(!ok) return res.status(401).json({ error: 'invalid-password' });
    const token = generateToken(user);
    res.json({ token, user: { id: user.id, username: user.username, is_admin: user.is_admin }});
  });

  // admin create user
  app.post('/api/users', verifyToken, async (req, res) => {
    if(!req.user.is_admin) return res.status(403).json({ error: 'forbidden' });
    const { username, password, is_admin } = req.body;
    if(!username || !password) return res.status(400).json({ error: 'missing' });
    const exists = await db.get('SELECT 1 FROM users WHERE username = ?', username);
    if(exists) return res.status(409).json({ error: 'exists' });
    const hash = await bcrypt.hash(password, 10);
    await db.run('INSERT INTO users (username, password_hash, is_admin) VALUES (?, ?, ?)', username, hash, is_admin ? 1 : 0);
    res.json({ ok: true });
  });

  // get state
  app.get('/api/state', verifyToken, async (req, res) => {
    const employees = await db.all('SELECT * FROM employees');
    const tasks = await db.all('SELECT * FROM tasks');
    const history = await db.all('SELECT * FROM history ORDER BY created_at DESC LIMIT 500');
    res.json({ employees, tasks, history });
  });

  app.post('/api/employee', verifyToken, async (req, res) => {
    const { name, photo, est_minutes } = req.body;
    const r = await db.run('INSERT INTO employees (name, photo, est_minutes) VALUES (?, ?, ?)', name, photo || '', est_minutes || 0);
    const id = r.lastID;
    io.emit('employee:update');
    res.json({ id });
  });

  // start task
  app.post('/api/task/start', verifyToken, async (req, res) => {
    const { employee_id, task_text } = req.body;
    const start_ts = Date.now();
    const r = await db.run('INSERT INTO tasks (employee_id, task_text, start_ts, status, created_by) VALUES (?, ?, ?, ?, ?)', employee_id, task_text || '', start_ts, 'running', req.user.id);
    const taskId = r.lastID;
    io.emit('task:started', { taskId, employee_id, task_text, start_ts });
    res.json({ ok: true, taskId, start_ts });
  });

  // pause task
  app.post('/api/task/pause', verifyToken, async (req, res) => {
    const { task_id } = req.body;
    const t = await db.get('SELECT * FROM tasks WHERE id = ?', task_id);
    if(!t) return res.status(404).json({ error: 'task-not-found' });
    const now = Date.now();
    let add = 0;
    if(t.start_ts && t.status === 'running') {
      add = Math.floor((now - t.start_ts)/1000);
    }
    const newElapsed = (t.elapsed_seconds || 0) + add;
    await db.run('UPDATE tasks SET elapsed_seconds = ?, status = ?, pause_ts = ? WHERE id = ?', newElapsed, 'paused', now, task_id);
    io.emit('task:paused', { task_id, newElapsed, pause_ts: now });
    res.json({ ok: true });
  });

  // done task
  app.post('/api/task/done', verifyToken, async (req, res) => {
    const { task_id } = req.body;
    const t = await db.get('SELECT * FROM tasks WHERE id = ?', task_id);
    if(!t) return res.status(404).json({ error: 'task-not-found' });
    const now = Date.now();
    let add = 0;
    if(t.start_ts && t.status === 'running') add = Math.floor((now - t.start_ts)/1000);
    const finalElapsed = (t.elapsed_seconds || 0) + add;
    await db.run('UPDATE tasks SET elapsed_seconds = ?, status = ?, pause_ts = ? WHERE id = ?', finalElapsed, 'done', now, task_id);
    await db.run('INSERT INTO history (employee_id, task_text, start_ts, end_ts) VALUES (?, ?, ?, ?)', t.employee_id, t.task_text, t.start_ts, now);
    io.emit('task:done', { task_id, employee_id: t.employee_id, end_ts: now });
    res.json({ ok: true });
  });

  // export
  app.get('/api/export', verifyToken, async (req, res) => {
    const rows = await db.all('SELECT h.*, e.name as employee_name FROM history h LEFT JOIN employees e ON e.id = h.employee_id ORDER BY h.created_at DESC');
    const header = ['Nome','Tarefa','Início','Término'];
    const data = rows.map(r => [r.employee_name || '', r.task_text || '', new Date(r.start_ts || 0).toLocaleString(), new Date(r.end_ts || 0).toLocaleString()]);
    const csv = stringify([header, ...data]);
    res.setHeader('Content-disposition', `attachment; filename=relatorio_anjun_${(new Date()).toISOString().slice(0,10)}.csv`);
    res.set('Content-Type', 'text/csv');
    res.send(csv);
  });

  app.use(express.static(path.join(__dirname, 'public')));

  io.on('connection', socket => {
    console.log('socket connected', socket.id);
    socket.on('ping', () => socket.emit('pong'));
  });

  server.listen(PORT, () => {
    console.log('Server running on port', PORT);
  });
})();
```

---

## `public/index.html` (frontend de teste mínimo)
> **Observação:** isso é apenas um front simples para você testar o backend. Depois eu adapto o painel que você já usa para consumir essa API e usar Socket.IO em tempo real.

```html
<!doctype html>
<html>
<head><meta charset="utf-8"><title>Anjun Backend Test</title></head>
<body>
<h2>Anjun Backend - Teste</h2>
<form id="loginForm">
  <input id="u" placeholder="usuário"><br>
  <input id="p" type="password" placeholder="senha"><br>
  <button type="submit">Entrar</button>
</form>
<pre id="out"></pre>
<script>
  const out = document.getElementById('out');
  document.getElementById('loginForm').addEventListener('submit', async (e)=>{
    e.preventDefault();
    const u = document.getElementById('u').value;
    const p = document.getElementById('p').value;
    const res = await fetch('/api/login', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({username:u,password:p})});
    const txt = await res.text();
    out.textContent = res.status + '\n' + txt;
  });
</script>
</body>
</html>
```

---

## `README_DEPLOY.md` — instruções rápidas (para avançar no Render)
```
1. Crie um repositório no GitHub com estes arquivos (package.json, server.js, init-db.sql, public/...).
2. No Render: New -> Web Service -> Connect a repository -> selecione o repositório.
3. Build command: leave empty (Node app)
4. Start command: `npm start` or `node server.js`
5. Add an environment variable JWT_SECRET with a strong secret.
6. Deploy. O Render vai instalar dependências e iniciar o servidor.
7. Acesse https://<seu-servico>.onrender.com e teste `/api/login` via postman ou o `public/index.html`.

Para rodar localmente:
1. `npm install`
2. `node server.js`
3. Abra http://localhost:3000

*Se quiser, eu mesmo posso montar o repositório e te passar o link para revisão antes de conectar ao Render.*
```

---
